<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Chess.com Accuracy & Performance Calculator</title>
<style>
  body{font-family:sans-serif;max-width:760px;margin:2rem auto;padding:0 1rem;line-height:1.4}
  textarea{width:100%;height:240px}
  input,button{padding:.5rem;font-size:1rem;margin-top:.5rem}
  pre{background:#f6f6f6;padding:1rem;border-radius:6px;overflow:auto}
  table{border-collapse:collapse;margin-top:1rem;width:100%}
  th,td{border:1px solid #ccc;padding:.4rem;text-align:center}
  th{background:#eee}
  caption{margin-bottom:.4rem;font-weight:bold}
</style>
</head>
<body>
<h2>Chess.com Accuracy / Performance Stats</h2>

<label>Player username (leave blank to auto-detect):<br>
  <input id="player" placeholder="e.g. robdragon">
</label>

<p>Paste the raw “Recent” games listing, then click <b>Calculate</b>.</p>
<textarea id="input" placeholder="Paste here…"></textarea><br>
<button onclick="calc()">Calculate</button>

<div id="output"></div>

<script>
  function calculateStandardDeviation(arr) {
  if (!Array.isArray(arr) || arr.length < 2) {
    // Standard deviation requires at least two data points for a sample
    return NaN; 
  }

  const mean = arr.reduce((sum, value) => sum + value, 0) / arr.length;

  const squaredDifferencesSum = arr.reduce((sum, value) => {
    return sum + Math.pow(value - mean, 2);
  }, 0);

  // For a sample, divide by (N - 1)
  const variance = squaredDifferencesSum / (arr.length - 1);

  return Math.sqrt(variance);
}
const stddev = calculateStandardDeviation;
const avg   = a => a.length ? a.reduce((x,y)=>x+y,0)/a.length : NaN;
function calc(){

  const txt   = document.getElementById('input').value;
  const outEl = document.getElementById('output');
  if(!txt.trim()){ outEl.textContent = 'Please paste some game text first.'; return; }

  const blocks = txt.split(/\n(?=\d+\s+min)/);
  if(!blocks.length){ outEl.textContent = 'No games detected.'; return; }

  /* ---------- detect player name if blank ---------- */
  let player = document.getElementById('player').value.trim();
  if(!player){
    const freq={};
    blocks.forEach(b=>[...b.matchAll(/([A-Za-z0-9_]+)\s*\(\d+\)/g)]
      .forEach(m=>freq[m[1]] = (freq[m[1]]||0)+1));
    player = Object.entries(freq).sort((a,b)=>b[1]-a[1])[0]?.[0]||'';
    if(!player){ outEl.textContent = 'Could not auto-detect username.'; return; }
  }

  /* ---------- containers ---------- */
  const make = ()=>({acc:[], wins:0, losses:0, opp:[]});
  const you  = {all:make(), white:make(), black:make()};
  const opp  = {all:make(), white:make(), black:make()};
  const daily = {};  /* keyed by date string */

  const scoreVal = s => (s==='½'||s==='0.5') ? 0.5 : parseFloat(s);
  // const avg   = a => a.length ? a.reduce((x,y)=>x+y,0)/a.length : NaN;
  const perf  = o => {
      const g=o.wins+o.losses;
      return g? ((o.wins-o.losses)/g)*400 + avg(o.opp) : NaN;
  };
  const fmt   = x => isNaN(x) ? '—' : x.toFixed(2);
  const fmtN = fixed => x => isNaN(x) ? '—' : x.toFixed(fixed);
  const estRt = a => isNaN(a) ? '—' : ((a-64)*100).toFixed(0);

  /* ---------- game loop ---------- */
  blocks.forEach(block=>{
    const nm = [...block.matchAll(/([A-Za-z0-9_]+)\s*\((\d+)\)/g)];
    if(nm.length<2) return;

    const [whiteN,whiteE] = [nm[0][1], +nm[0][2]];
    const [blackN,blackE] = [nm[1][1], +nm[1][2]];
    const colour = player.toLowerCase()===whiteN.toLowerCase() ? 'white'
                 : player.toLowerCase()===blackN.toLowerCase() ? 'black' : null;
    if(!colour) return;

    const after = block.slice(nm[1].index + nm[1][0].length);
    const res   = [...after.matchAll(/\b(?:1|0|½|0\.5)\b/g)].slice(0,2).map(m=>scoreVal(m[0]));
    if(res.length<2) return;
    const [wScr,bScr] = res;

    const accNums = [...after.matchAll(/\b\d{1,3}(?:\.\d+)?\b/g)]
                    .map(m=>+m[0]).filter(n=>n>=5&&n<=100).slice(0,2);
    if(accNums.length<2) return;
    const [wAcc,bAcc] = accNums;

    /* date extraction */
    const dateMatch = block.match(/\b[A-Z][a-z]{2} \d{1,2}, \d{4}\b/);
    const dKey = dateMatch?dateMatch[0]:'Unknown';

    const youAcc   = colour==='white'?wAcc:bAcc;
    const oppAcc   = colour==='white'?bAcc:wAcc;
    const oppElo   = colour==='white'?blackE:whiteE;
    const youWin   = (colour==='white' && wScr>bScr) || (colour==='black' && bScr>wScr);
    const youLoss  = (colour==='white' && wScr<bScr) || (colour==='black' && bScr<wScr);
    const oppCol   = colour==='white'?'black':'white';

    /* -- push to your stats -- */
    ['all',colour].forEach(k=>{
      you[k].acc.push(youAcc);
      you[k].opp.push(oppElo);
      if(youWin)  you[k].wins++;
      if(youLoss) you[k].losses++;
    });

    /* -- push to opponent combined stats (draws ignored) -- */
    if(youWin||youLoss){
      ['all',oppCol].forEach(k=>{
        opp[k].acc.push(oppAcc);
        opp[k].opp.push(colour==='white'?whiteE:blackE);
        if(youLoss) opp[k].wins++;  /* they won */
        if(youWin)  opp[k].losses++;
      });
    }

    /* -- daily bucket -- */
    if(!daily[dKey]) daily[dKey]=make();
    daily[dKey].acc.push(youAcc);
    daily[dKey].opp.push(oppElo);
    if(youWin)  daily[dKey].wins++;
    if(youLoss) daily[dKey].losses++;
  });

  const simedGames = {
    overall: simGames(you.all.acc, opp.all.acc),
    white: simGames(you.white.acc, opp.black.acc),
    black: simGames(you.black.acc, opp.white.acc),
    
  }

  const gameDist = {
    overall: winStatsScore(avg(you.all.acc), stddev(you.all.acc), avg(opp.all.acc), stddev(opp.all.acc), corr = 0, N = you.all.acc.length),
    white: winStatsScore(avg(you.white.acc), stddev(you.white.acc), avg(opp.black.acc), stddev(opp.black.acc), corr = 0, N = you.white.acc.length),
    black: winStatsScore(avg(you.black.acc), stddev(you.black.acc), avg(opp.white.acc), stddev(opp.white.acc), corr = 0, N = you.black.acc.length),
  }

  const accuracyDist = {
    overall: statsSummary(you.all.acc),
    white: statsSummary(you.white.acc),
    black: statsSummary(you.black.acc),

  }

  // console.log(accuracyDist);

  /* ---------- build textual summary ---------- */
  const summary =
`Stats for ${player}

YOUR average accuracy:
  Overall : ${fmt(avg(you.all.acc))} Acc -> Rating ${fmt((avg(you.all.acc)-64)*100)} -> Stddev ${fmt(stddev(you.all.acc))}
  White   : ${fmt(avg(you.white.acc))} Acc -> Rating ${fmt((avg(you.white.acc)-64)*100)} -> Stddev ${fmt(stddev(you.white.acc))}
  Black   : ${fmt(avg(you.black.acc))} Acc -> Rating ${fmt((avg(you.black.acc)-64)*100)} -> Stddev ${fmt(stddev(you.black.acc))}

YOUR performance rating:
  Overall : ${fmt(perf(you.all))}
  White   : ${fmt(perf(you.white))}
  Black   : ${fmt(perf(you.black))}
  

OPPONENTS’ combined average accuracy:
  Overall : ${fmt(avg(opp.all.acc))} -> Rating ${fmt((avg(opp.all.acc)-64)*100)} -> Stddev ${fmt(stddev(opp.all.acc))}
  White   : ${fmt(avg(opp.white.acc))}   -> Rating ${fmt((avg(opp.white.acc)-64)*100)} -> Stddev ${fmt(stddev(opp.white.acc))}
  Black   : ${fmt(avg(opp.black.acc))}   -> Rating ${fmt((avg(opp.black.acc)-64)*100)} -> Stddev ${fmt(stddev(opp.black.acc))}

OPPONENTS’ combined performance rating:
  Overall : ${fmt(perf(opp.all))} -> Actual Average ${fmt(avg(opp.all.opp))}
  White   : ${fmt(perf(opp.white))} -> Actual Average ${fmt(avg(opp.white.opp))}
  Black   : ${fmt(perf(opp.black))} -> Actual Average ${fmt(avg(opp.black.opp))}

EXPECTED WIN/LOSS SIM
  
  Overall : Est ${fmt(simedGames.overall.a)}% -> est Elo ${fmt(estimateElo(avg(opp.all.opp), simedGames.overall.a/100))} -> Actual % ${fmt((you.all.wins / you.all.acc.length)*100)}% 
  White : Est ${fmt(simedGames.white.a)}% -> est Elo ${fmt(estimateElo(avg(opp.white.opp), simedGames.white.a/100))} -> Actual % ${fmt((you.white.wins / you.white.acc.length)*100)}%
  Black : Est ${fmt(simedGames.black.a)}% -> est Elo ${fmt(estimateElo(avg(opp.black.opp), simedGames.black.a/100))} -> Actual % ${fmt((you.black.wins / you.black.acc.length)*100)}%

EXPECTED WIN/LOSS MATH
  Side    |${pad(10)('Overall')}|${pad(10)('White')}|${pad(10)('Black')}|

  Est Win%
  ${pad(8)('5%')}|${pad(9)(fmt(gameDist.overall.ci95[0]*100))}%|${pad(9)(fmt(gameDist.white.ci95[0]*100))}%|${pad(9)(fmt(gameDist.black.ci95[0]*100))}%|
  ${pad(8)('Avg')}|${pad(9)(fmt(gameDist.overall.p*100))}%|${pad(9)(fmt(gameDist.white.p*100))}%|${pad(9)(fmt(gameDist.black.p*100))}%|
  ${pad(8)('95%')}|${pad(9)(fmt(gameDist.overall.ci95[1]*100))}%|${pad(9)(fmt(gameDist.white.ci95[1]*100))}%|${pad(9)(fmt(gameDist.black.ci95[1]*100))}%|
  
  ${pad(8)('StdErr')}|${pad(9)('±'+fmt(gameDist.overall.seN*100))}%|${pad(9)('±'+fmt(gameDist.white.seN*100))}%|${pad(9)('±'+fmt(gameDist.black.seN*100))}%|

  Est Wins Vs Actual Wins
  ${pad(8)('5%')}|${pad(10)(gameDist.overall.eN_ci95[0]+ ' of ' + you.all.acc.length)}|${pad(10)(gameDist.white.eN_ci95[0]+ ' of ' + you.white.acc.length)}|${pad(10)(gameDist.black.eN_ci95[0]+ ' of ' + you.black.acc.length)}|
  ${pad(8)('Avg')}|${pad(10)(gameDist.overall.eN_p + ' of ' + you.all.acc.length)}|${pad(10)(gameDist.white.eN_p+ ' of ' + you.white.acc.length)}|${pad(10)(gameDist.black.eN_p+ ' of ' + you.black.acc.length)}|
  ${pad(8)('95%')}|${pad(10)(gameDist.overall.eN_ci95[1] + ' of ' + you.all.acc.length)}|${pad(10)(gameDist.white.eN_ci95[1]+ ' of ' + you.white.acc.length)}|${pad(10)(gameDist.black.eN_ci95[1]+ ' of ' + you.black.acc.length)}|
  
  ${pad(8)('Actual')}|${pad(10)(you.all.wins+ ' of ' +you.all.acc.length)}|${pad(10)(you.white.wins+ ' of ' +you.white.acc.length)}|${pad(10)(you.black.wins+ ' of ' +you.black.acc.length)}|

  Est Performance Rating
  ${pad(8)('5%')}|${pad(10)(fmtN(0)(estimateElo(avg(opp.all.opp), gameDist.overall.ci95[0])))}|${pad(10)(fmtN(0)(estimateElo(avg(opp.all.opp), gameDist.white.ci95[0])))}|${pad(10)(fmtN(0)(estimateElo(avg(opp.all.opp), gameDist.black.ci95[0])))}|
  ${pad(8)('Avg')}|${pad(10)(fmtN(0)(estimateElo(avg(opp.all.opp), gameDist.overall.p)))}|${pad(10)(fmtN(0)(estimateElo(avg(opp.all.opp), gameDist.white.p)))}|${pad(10)(fmtN(0)(estimateElo(avg(opp.all.opp), gameDist.black.p)))}|
  ${pad(8)('95%')}|${pad(10)(fmtN(0)(estimateElo(avg(opp.all.opp), gameDist.overall.ci95[1])))}|${pad(10)(fmtN(0)(estimateElo(avg(opp.white.opp), gameDist.white.ci95[1])))}|${pad(10)(fmtN(0)(estimateElo(avg(opp.black.opp), gameDist.black.ci95[1])))}|
  
  ${pad(8)('StdErr')}|${pad(10)('±'+fmtN(0)(stdErrEstimatedEloDiff(avg(opp.all.opp), gameDist.overall.p, gameDist.overall.seN)))}|${pad(10)('±'+fmtN(0)(stdErrEstimatedEloDiff(avg(opp.white.opp), gameDist.white.p, gameDist.white.seN)))}|${pad(10)('±'+fmtN(0)(stdErrEstimatedEloDiff(avg(opp.black.opp), gameDist.black.p, gameDist.black.seN)))}|

  Est Accuracy
  ${pad(8)('5%')}|${pad(10)(fmt(accuracyDist.overall.ci95[0]))}|${pad(10)(fmt(accuracyDist.white.ci95[0]))}|${pad(10)(fmt(accuracyDist.black.ci95[0]))}|
  ${pad(8)('Avg')}|${pad(10)(fmt(accuracyDist.overall.mean))}|${pad(10)(fmt(accuracyDist.white.mean))}|${pad(10)(fmt(accuracyDist.black.mean))}|
  ${pad(8)('95%')}|${pad(10)(fmt(accuracyDist.overall.ci95[1]))}|${pad(10)(fmt(accuracyDist.white.ci95[1]))}|${pad(10)(fmt(accuracyDist.black.ci95[1]))}|
  
  ${pad(8)('StdErr')}|${pad(10)('±'+fmt(accuracyDist.overall.se))}|${pad(10)('±'+fmt(accuracyDist.white.se))}|${pad(10)('±'+fmt(accuracyDist.black.se))}|

  Est Strength from Accuracy
  ${pad(8)('5%')}|${pad(10)(fmt((accuracyDist.overall.ci95[0]-64)*100))}|${pad(10)(fmt((accuracyDist.white.ci95[0]-64)*100))}|${pad(10)(fmt((accuracyDist.black.ci95[0]-64)*100))}|
  ${pad(8)('Avg')}|${pad(10)(fmt((accuracyDist.overall.mean-64)*100))}|${pad(10)(fmt((accuracyDist.white.mean-64)*100))}|${pad(10)(fmt((accuracyDist.black.mean-64)*100))}|
  ${pad(8)('95%')}|${pad(10)(fmt((accuracyDist.overall.ci95[1]-64)*100))}|${pad(10)(fmt((accuracyDist.white.ci95[1]-64)*100))}|${pad(10)(fmt((accuracyDist.black.ci95[1]-64)*100))}|
  
  ${pad(8)('StdErr')}|${pad(10)('±'+fmt(accuracyDist.overall.se*100))}|${pad(10)('±'+fmt(accuracyDist.white.se*100))}|${pad(10)('±'+fmt(accuracyDist.black.se*100))}|

Games counted:
  You         – Overall ${you.all.acc.length}  |  White ${you.white.acc.length}  |  Black ${you.black.acc.length}
  Opponents   – Overall ${opp.all.acc.length}  |  White ${opp.white.acc.length}  |  Black ${opp.black.acc.length}
  `;

  // console.log(opp);
  console.log(gameDist);


  /* ---------- build day-by-day table ---------- */
  const rows = Object.keys(daily)
    .sort((a,b)=>new Date(a)-new Date(b))
    .map(d=>{
      const o = daily[d];
      const a = avg(o.acc);
      const perfD = perf(o);
      return `<tr><td>${d}</td><td>${o.acc.length}</td><td>${fmt(a)}</td><td>${estRt(a)}</td><td>${fmt(perfD)}</td><td>${o.wins}-${o.losses}</td></tr>`;
    }).join('');

  const tableHTML =
`<table>
  <caption>Day-by-day summary (you only)</caption>
  <tr><th>Date</th><th>Games</th><th>Avg&nbsp;accuracy</th><th>Est.&nbsp;rating</th><th>Perf.&nbsp;rating</th><th>W-L</th></tr>
  ${rows || '<tr><td colspan="6">No games</td></tr>'}
</table>`;

  /* ---------- inject into page ---------- */
  outEl.innerHTML = `<pre>${summary}</pre>${tableHTML}`;
}


function normalRandom(mu = 0, sigma = 1) {
  let u = 0, v = 0;
  // Ensure u and v are never 0
  while (u === 0) u = Math.random();
  while (v === 0) v = Math.random();

  // Box-Muller transform
  const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);

  // Scale and shift
  return mu + sigma * z;
}

function simGames(a_acc, b_acc) {
  const GAMES = 1000;
  const a_avg = avg(a_acc);
  const b_avg = avg(b_acc);
  const a_sd = stddev(a_acc);
  const b_sd = stddev(b_acc);
  let a_wins = 0, b_wins = 0;
  const accum = [];
  for(let i = 0; i < GAMES; i++)
  {
    let a_p = normalRandom(a_avg, a_sd);
    let b_p = normalRandom(b_avg, b_sd);
    accum.push([a_p, b_p]);
    if(a_p > b_p) a_wins++;
    else if(a_p < b_p) b_wins++;
    // else draw
  }
  // console.log({a_acc, b_acc, a_sd, b_sd, a_wins, b_wins, accum});
  return {a: (a_wins / GAMES)*100, b:(b_wins / GAMES)*100};
}

function stdErrEstimatedEloDiff(oppElo, p, se) {
  return estimateElo(oppElo, p+se) - estimateElo(oppElo, p);
}

function estimateElo(oppElo, p) {
  // if (p <= 0 || p >= 1) {
  if (p < 0 || p > 1) {
    // console.log(p);
    throw new Error("Win probability must be between 0 and 1 (exclusive).");
  }
  if(p === 0) return oppElo - 400;
  if(p === 1) return oppElo + 400;

  return oppElo - 400 * Math.log10((1 - p) / p);
}

function winStatsScore(meanA, sdA, meanB, sdB, corr = 0, N = null) {
  const p = winProbabilityScore(meanA, sdA, meanB, sdB, corr); // from earlier
  const perMatchSD = Math.sqrt(p * (1 - p));

  let seN = null, ci95 = null;
  if (N != null && N > 0) {
    seN = Math.sqrt(p * (1 - p) / N);
    const z = 1.96;
    ci95 = [Math.max(0, p - z * seN), Math.min(1, p + z * seN)];
  }
  return { p, perMatchSD, seN, ci95, N, eN_p: Math.round(N * p), eN_ci95: ci95.map(ci => Math.round(N * ci)), eN_seN: Math.round(seN * p)};
}

// ---- dependency (same as earlier answer) ----
function winProbabilityScore(meanA, sdA, meanB, sdB, corr = 0) {
  if (sdA < 0 || sdB < 0) throw new Error("Standard deviations must be >= 0.");
  if (corr < -1 || corr > 1) throw new Error("corr must be between -1 and 1.");

  const denom = Math.sqrt(sdA*sdA + sdB*sdB - 2*corr*sdA*sdB);
  if (denom === 0) return meanA > meanB ? 1 : meanA < meanB ? 0 : 0.5;
  const z = (meanA - meanB) / denom;
  return standardNormalCDF(z);
}

function standardNormalCDF(x) { return 0.5 * (1 + erf(x / Math.SQRT2)); }
function erf(x) {
  const sign = x >= 0 ? 1 : -1; x = Math.abs(x);
  const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;
  const t = 1 / (1 + p * x);
  const y = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t * Math.exp(-x*x);
  return sign * y;
}

function padLeft(value, length, char = '0') {
  const str = String(value);
  if (str.length >= length) return str;
  return char.repeat(length - str.length) + str;
}

function pad(len)
{
  return value => padLeft(value, len, ' ');
}

function statsSummary(sample) {
  if (!sample || sample.length === 0) {
    throw new Error("Sample must be a non-empty array of numbers.");
  }

  const n = sample.length;

  // --- mean ---
  const mean = sample.reduce((a, b) => a + b, 0) / n;

  // --- sample standard deviation (unbiased, denom n-1) ---
  const variance = sample.reduce((a, b) => a + (b - mean) ** 2, 0) / (n - 1);
  const stddev = Math.sqrt(variance);

  // --- standard error of the mean ---
  const se = stddev / Math.sqrt(n);

  // --- 95% CI (using normal approx, z=1.96) ---
  const z95 = 1.96;
  const ci95 = [mean - z95 * se, mean + z95 * se];

  // --- 5% & 95% quantiles (empirical percentiles) ---
  const sorted = [...sample].sort((a, b) => a - b);
  const q = (p) => {
    const idx = (n - 1) * p;
    const lower = Math.floor(idx);
    const upper = Math.ceil(idx);
    if (lower === upper) return sorted[lower];
    return sorted[lower] * (upper - idx) + sorted[upper] * (idx - lower);
  };
  const q5 = q(0.05);
  const q95 = q(0.95);

  return {
    mean,
    stddev,
    ci95,
    q5,
    q95,
    se,
    variance
  };
}

</script>
</body>
</html>
